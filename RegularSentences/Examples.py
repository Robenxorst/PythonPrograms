import re # библиотека регулярных выражений

# [] -- указываем множество подходящих символов
# \ -- экранирует метасимвол(воспринимается как обычный символ)
# ^ -- множество символов, которые нам не подходят
# . -- любой единичный символ
# * -- любое число символов включая 0
# + -- любое число символов, исключая 0
# {2, 4} -- нас устраивает от 2ух до 4ех символов вхождения
# По умолчанию метасимволы действуют жадно.
# Функция match вернет самый длинную последовательность.
# ?(после метасимвола) -- говорит действовать НЕ жадно, а найти минимальное выражение
# (test) -- используется для группировки символов в один элемент
# (с целью дальнейшего применения, например повтора);
# (test|text) -- нам подходит одна из групп символов(операция или);
# Метасимвол | имеет наименьший приоритет -- можно разделять им выражения на две части;
# match.groups() -- выводит принадлежность нашей строки к той или иной группе;
# Мы можем использовать уже найденную группу прямо внутри регулярного выражения
# (...)-\1 -- эквивалентно найди нам такую же группу под скобками 1,
# которую ты собрал ранее(группы символов должны совпадать);
# Группу мы можем переиспользовать внутри re.sub:
# duplicates = re.sub(pattern, r"\1", string)
# \d - [0-9] -- цифры
# \D - ^[0-9] -- не цифры
# \s - пробельные символы [ \t\n\r\f\v]
# \S -[^ \t\n\r\f\v]
# \w - буквы + цифры
# \W - НЕ буквы + цифры

pattern = r"ab*c"
string = "acc"
# слайсинг - string[1:4];
# подходит ли начало строки под наш шаблон?
# re.IGNORECASE - игнорируем заглавные или строчные у нас буквы;
# re.DEBUG -- подробный вывод происходящего в шаблоне
match_object = re.match(pattern, string, re.IGNORECASE | re.DEBUG)
print(match_object)

# Есть ли подстроки подходящие под наш шаблон
search_object = re.search(pattern, string)
print(search_object)

# Поиск всех подстрок в строке
string = "abbbc, abc, a.c, ac, aZc"
all_inclusions = re.findall(pattern, string)
print(all_inclusions)

# Замена подстрок в строке
fixed_typos = re.sub(pattern, "abc", string)
print(fixed_typos)

# Оставляем лишь одно слово из пары совпадающих слов
pattern = r"(\w+)-\1"
string = "test-test chow-chow"
duplicates = re.sub(pattern, r"\1", string)
print(duplicates)